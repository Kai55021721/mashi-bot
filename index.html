<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Invaders del Guardián</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: monospace; overflow: hidden; touch-action: manipulation; }
        canvas { display: block; width: 100vw; height: 100vh; background: #000011; border: 2px solid #d4af37; box-shadow: 0 0 20px #d4af37; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; font-size: 14px; z-index: 10; background: rgba(0,0,0,0.7); padding: 5px; border-radius: 5px; }
        #level { position: absolute; top: 10px; right: 10px; font-size: 14px; z-index: 10; background: rgba(0,0,0,0.7); padding: 5px; border-radius: 5px; }
        #highScore { position: absolute; top: 40px; right: 10px; font-size: 12px; color: #888; z-index: 10; background: rgba(0,0,0,0.7); padding: 5px; border-radius: 5px; }
        #gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; display: none; z-index: 20; background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #d4af37; border-radius: 10px; width: 90%; max-width: 300px; }
        #submit, #restart { padding: 10px 20px; background: #8b4513; color: #d4af37; border: 1px solid #d4af37; cursor: pointer; font-family: monospace; font-size: 14px; margin: 5px; border-radius: 5px; width: 100%; }
        #submit:hover, #restart:hover { background: #d4af37; color: #000; }
    </style>
</head>
<body>
    <div id="ui">Puntuación: <span id="score">0</span> | Vidas: <span id="lives">3</span></div>
    <div id="level">Nivel: <span id="currentLevel">1</span></div>
    <div id="highScore">Mejor: <span id="highScoreVal">0</span></div>
    <canvas id="canvas"></canvas>
    <div id="gameOver">
        <h2>¡Invasión Detenida!</h2>
        <p>Puntuación: <span id="finalScore">0</span></p>
        <p>Nivel: <span id="finalLevel">1</span></p>
        <button id="submit" onclick="submitScore()">Guardar en el Templo</button>
        <button id="restart" onclick="restartGame()">Reiniciar</button>
    </div>
    <script>
        const tg = window.Telegram.WebApp;
        tg.ready(); tg.expand();
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const levelEl = document.getElementById('currentLevel');
        const highScoreEl = document.getElementById('highScoreVal');
        const gameOverDiv = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');
        const finalLevelEl = document.getElementById('finalLevel');

        let player = { x: canvas.width / 2 - 15, y: canvas.height - 100, w: 30, h: 20, speed: 8, lives: 3 };
        let bullets = []; let enemyBullets = []; let enemies = []; let barriers = []; let particles = [];
        let score = 0; let level = 1; let gameOver = false; let keys = {}; let lastShot = 0; let fireRate = 200;
        let enemyMoveDir = 1; let enemyMoveDown = false; let highScore = localStorage.getItem('mashiHighScore') || 0;
        highScoreEl.textContent = highScore; let isDragging = false; let isMouseDown = false;

        function createBarriers() {
            barriers = []; for (let i = 0; i < 4; i++) barriers.push({ x: (canvas.width / 5) * i + 20, y: canvas.height - 200, w: 60, h: 40, health: 3 });
        }

        function initLevel() {
            enemies = []; enemyBullets = []; createBarriers();
            const rows = 5; const cols = Math.floor(canvas.width / 40); const enemyW = 30; const enemyH = 20;
            const startX = 20; const startY = 50;
            for (let row = 0; row < rows; row++) for (let col = 0; col < cols; col++) {
                enemies.push({ x: startX + col * enemyW, y: startY + row * enemyH, w: enemyW, h: enemyH,
                    type: row < 2 ? 'boss' : row < 4 ? 'mid' : 'small', color: row < 2 ? '#ff00ff' : row < 4 ? '#00ff00' : '#ffff00', shootRate: row < 2 ? 1000 : 2000 });
            }
        }

        document.addEventListener('keydown', e => { keys[e.key] = true; e.preventDefault(); });
        document.addEventListener('keyup', e => { keys[e.key] = false; });

        // Touch
        canvas.addEventListener('touchstart', e => { e.preventDefault(); isDragging = true; updateMousePos(e.touches[0]); });
        canvas.addEventListener('touchmove', e => { e.preventDefault(); if (isDragging) updateMousePos(e.touches[0]); });
        canvas.addEventListener('touchend', e => { e.preventDefault(); isDragging = false; });

        // Mouse
        canvas.addEventListener('mousedown', e => { isMouseDown = true; updateMousePos(e); });
        canvas.addEventListener('mousemove', e => { if (isMouseDown) updateMousePos(e); });
        canvas.addEventListener('mouseup', e => { isMouseDown = false; });
        canvas.addEventListener('mouseleave', e => { isMouseDown = false; });

        function updateMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            player.x = (e.clientX - rect.left) * (canvas.width / rect.width) - player.w / 2;
            player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));
        }

        function shoot() { if (Date.now() - lastShot > fireRate) {
            bullets.push({ x: player.x + player.w/2 - 2, y: player.y, w: 4, h: 8, speed: 7 }); lastShot = Date.now();
            createParticles(player.x + player.w/2, player.y + player.h, '#ffff00', 5);
        }}

        function updatePlayer() {
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;
            if ((keys[' '] || isDragging || isMouseDown) && Date.now() - lastShot > fireRate) shoot();
        }

        function updateBullets() {
            bullets = bullets.filter(b => { b.y -= b.speed; return b.y > -b.h; });
            enemyBullets = enemyBullets.filter(b => { b.y += b.speed; return b.y < canvas.height + b.h; });
        }

        function enemyShoot() { if (enemies.length > 0 && Math.random() < 0.01 * level) {
            const shooter = enemies[Math.floor(Math.random() * enemies.length)];
            enemyBullets.push({ x: shooter.x + shooter.w/2 - 2, y: shooter.y + shooter.h, w: 4, h: 8, speed: 3 });
        }}

        function updateEnemies() {
            let edgeHit = false; enemies.forEach(e => { e.x += enemyMoveDir * 0.5 * level;
                if (e.x <= 0 || e.x + e.w >= canvas.width) edgeHit = true; });
            if (edgeHit) { enemyMoveDir *= -1; enemies.forEach(e => { e.y += 20;
                if (e.y + e.h > player.y - 100) enemyMoveDown = true; }); }
            if (enemyMoveDown) { enemies.forEach(e => e.speed += 0.1); enemyMoveDown = false; }
            enemies = enemies.filter(e => e.y < canvas.height); enemyShoot();
        }

        function checkCollisions() {
            bullets.forEach((b, bi) => { enemies.forEach((e, ei) => {
                if (b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
                    bullets.splice(bi, 1); enemies.splice(ei, 1); score += e.type === 'boss' ? 50 : e.type === 'mid' ? 30 : 10;
                    scoreEl.textContent = score; if (score > highScore) { highScore = score; highScoreEl.textContent = highScore; localStorage.setItem('mashiHighScore', highScore); }
                    createParticles(e.x + e.w/2, e.y + e.h/2, '#ffaa00', 12);
                }}); barriers.forEach((bar, bai) => {
                if (b.x < bar.x + bar.w && b.x + b.w > bar.x && b.y < bar.y + bar.h && b.y + b.h > bar.y) {
                    bullets.splice(bi, 1); bar.health--; if (bar.health <= 0) barriers.splice(bai, 1);
                }}); });

            enemyBullets.forEach((eb, ebi) => { if (eb.x < player.x + player.w && eb.x + eb.w > player.x && eb.y < player.y + player.h && eb.y + eb.h > player.y) {
                enemyBullets.splice(ebi, 1); player.lives--; livesEl.textContent = player.lives; createParticles(player.x + player.w/2, player.y + player.h/2, '#ff0000', 20);
                if (player.lives <= 0) endGame(); } barriers.forEach((bar, bai) => {
                if (eb.x < bar.x + bar.w && eb.x + eb.w > bar.x && eb.y < bar.y + bar.h && eb.y + eb.h > bar.y) {
                    enemyBullets.splice(ebi, 1); bar.health--; if (bar.health <= 0) barriers.splice(bai, 1);
                }}); });

            enemies.forEach((e, ei) => { if (e.x < player.x + player.w && e.x + e.w > player.x && e.y < player.y + player.h && e.y + e.h > player.y) {
                player.lives--; livesEl.textContent = player.lives; if (player.lives <= 0) endGame();
            }});
        }

        function checkLevelUp() { if (enemies.length === 0) { level++; levelEl.textContent = level; fireRate = Math.max(150, fireRate - 25); initLevel(); }}

        function createParticles(x, y, color, count) { for (let i = 0; i < count; i++) particles.push({ x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8, life: 40, color }); }

        function updateParticles() { particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life--; p.vx *= 0.97; p.vy *= 0.97; if (p.life <= 0) particles.splice(i, 1); }); }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#fff';
            for (let i = 0; i < 100; i++) ctx.fillRect((i * 137 + Date.now() * 0.05) % canvas.width, (i * 173) % canvas.height, 1, 1);

            ctx.fillStyle = '#00ff00'; ctx.beginPath(); ctx.moveTo(player.x + player.w/2, player.y); ctx.lineTo(player.x, player.y + player.h); ctx.lineTo(player.x + player.w, player.y + player.h); ctx.closePath(); ctx.fill();

            ctx.fillStyle = '#ffff00'; bullets.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));
            ctx.fillStyle = '#ff0000'; enemyBullets.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));

            enemies.forEach(e => { ctx.fillStyle = e.color; ctx.fillRect(e.x, e.y, e.w, e.h); ctx.fillStyle = '#fff'; ctx.fillRect(e.x + e.w/4, e.y + e.h/4, 3, 3); });

            barriers.forEach(bar => { ctx.fillStyle = bar.health > 1 ? '#00ffff' : '#ffff00'; ctx.fillRect(bar.x, bar.y, bar.w, bar.h); });

            particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 40; ctx.fillRect(p.x, p.y, 3, 3); }); ctx.globalAlpha = 1;

            if (gameOver) gameOverDiv.style.display = 'block';
        }

        function endGame() { gameOver = true; finalScoreEl.textContent = score; finalLevelEl.textContent = level; }

        function restartGame() { player = { x: canvas.width / 2 - 15, y: canvas.height - 100, w: 30, h: 20, speed: 8, lives: 3 };
            bullets = []; enemyBullets = []; particles = []; score = 0; level = 1; fireRate = 200; enemyMoveDir = 1; gameOver = false;
            scoreEl.textContent = score; livesEl.textContent = player.lives; levelEl.textContent = level; gameOverDiv.style.display = 'none'; initLevel(); }

        function submitScore() { tg.sendData(JSON.stringify({ score, level })); tg.close(); }

        function gameLoop() { if (!gameOver) { updatePlayer(); updateBullets(); updateEnemies(); updateParticles(); checkCollisions(); checkLevelUp(); } draw(); requestAnimationFrame(gameLoop); }

        initLevel(); gameLoop();
    </script>
</body>
</html>